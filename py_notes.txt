процедурное программирование - описание инструкций компьютеру в виде упорядоченных последовательностей

динамическая типизация - переменным можно повторно присваивать значени, относящиеся к другим типам или классам

изменяемый объект - такой объект содержимое которого может меняться после создания
неизменяемый объект - содержимое меняется, но создается новый объект

логические значения: True и False

встроенные типа данных в python:
1. списки (list)
2. кортежи (tuple)
3. диапазоны (range)
4. строковые значения (string)
5. двоичные данные (binary)

создать новую последовательность на основе существующей можно с помощью срезов:
имя_среза[start:stop:step]
start - индекс первого элемента новой последовательности,
stop - первый индекс ЗА ЕЕ пределами,
step - расстояние между элементами. по умолчанию: start = 0, stop - длина последовательности, а step = 1

# списки
- упорядоченный набор элементов произвольного типа. использует квадратные скобки
- для создания пустого или списка на основе другого объекта можно использовать функцию list()
- элементы списка могут быть разного типа
- списковые включения - позвляют использовать функциональность цикла for с помощью одной строчки кода
- являются изменяемым объектом. содержимое меняется без создания нового списка

# строковые значения
- кодировка по умолчанию в python UTF-8
- создавать СЗ можно с помощью конструктора str(), либо 'text' / "text"
- метод strip() - возвращает строку без пробелов в начале или в конце. существуют также методы, которые удаляют проблем только справа или слева
строк 48 (книга)
- неизменяемые объекты. при изменении содержимого уже существующей строки, создается новая

# ассоциативные массивы
наиболее часто используемые в python. задает соответствие ключ-значение. ключами могут быть строкИ, числа, пользовательские объекты и любые другие неизменяемые типы

# функции как объекты
- - можно передавать и хранить в структурах данных (например, в списках)

# анонимные функции
- если требуется маленькая функция, можно создать безымянную (анонимную) функцию. в общем случае следует ограничить их применение ситуациями, в которых одна функция ожидает в качестве аргумента другую маленькую функцию
- синтаксис lambda <Параметр>: <Возвращаемое значение>
